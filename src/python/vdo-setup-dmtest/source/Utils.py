#!/usr/bin/env python3
"""
  Utils - General vdo_setup_dmtest constants and utilities

  Copyright (c) 2024 Red Hat
"""

from __future__ import print_function

import logging
import os
import subprocess
import textwrap
import validators

logger = logging.getLogger('vdo-setup-dmtest')
INDENT = '  '

def createSigningCertKeyPair(certPath, genkeyPath):
  """
  Create a PEM signing certificate key pair based on an x509.genkey file
  """
  logger.info("Creating the certificate/key pair needed for signing the module")
  keyPath = os.path.join(os.path.dirname(certPath), 'signing_key.x509')

  try:
    opensslCmd = ['sudo openssl req -new -nodes -utf8 -sha512 -days 36500 -batch -x509',
                  '-config', genkeyPath, '-outform PEM -out', certPath, '-keyout', keyPath]
    result = runCommand(opensslCmd)
    assert result.returncode == 0, 'OpenSSL command failed'
  except Exception as error:
    logger.error("Error - {0}".format(error))
    return False
  return True

def createX509Genkey(certsDir):
  """
  Create a x509.genkey file in the specified kernel certificate directory
  
  Creation is accomplished by creating the file in the current directory, and then copying it
  to the specified certificate directory. This is done to account for python file write
  permissons in root directories. In the case that the genkey file already exists in the
  current directory, it will be overwritten.
  """
  filename = 'x509.genkey'
  genkeyFile = os.path.join(os.getcwd(), filename)

  logger.info("Creating the x509.genkey config needed for certificate/key creation")
  try:
    with open(genkeyFile, 'w+') as fh:
      fh.write(textwrap.dedent("""\
        [ req ]
        default_bits = 4096
        distinguished_name = req_distinguished_name
        prompt = no
        string_mask = utf8only
        x509_extensions = myexts
        [ req_distinguished_name ]
        CN = Build time autogenerated kernel key for test modules
        [ myexts ]
        basicConstraints=critical,CA:FALSE
        keyUsage=digitalSignature
        subjectKeyIdentifier=hash
        authorityKeyIdentifier=keyid
        """))

    result = runCommand(['sudo cp', genkeyFile, certsDir], logger)
    assert result.returncode == 0, " ".join(['Copying', filename, 'to', certsDir, 'failed'])
  except Exception as error:
    logger.error("Error - {0}".format(error))
    return False
  return True

def isExecutable(filePath):
  """
  Check if the file at the specified path is executable
  """
  return os.path.isfile(filePath) and os.access(filePath, os.X_OK)

def isURL(inputString):
  """
  Check if the input string is a URL
  """
  # The validators utility cannot evaluate git SSH URLs (nor can the Python standard urllib.parse).
  # Similar to urllib.parse, it only verifies that the input has the proper format of a URL. It is
  # an improvement over urllib.parse because it will catch if there are an invalid number of '/'
  # between the URL scheme and netloc, along with whether the scheme is invalid.
  if inputString.startswith('git@'):
    # Return true for git SSH URLs. gitPython will evaluate the url downstream.
    return True
  else:
    valid = validators.url(inputString)
    if not valid:
      return False
  return True

def runCommand(args, ignoreErrors=False):
  """
  Run a shell command
  """
  if isinstance(args, str):
    command = args
  else:
    command = " ".join(args)
  
  logger.debug("Running Command: {0}".format(command))
  result = subprocess.run(command, shell=True, text=True, capture_output=True)

  if (not ignoreErrors) and (result.returncode != 0):
    logger.error("Command '{cmd}' failed: stderr:\n{err}\nstdout:\n{out}".format(
      cmd = command, err = result.stderr, out = result.stdout))
  elif result.stdout != "":
    logger.debug("runCommand stdout:\n{0}".format(result.stdout.rstrip()))
  return result

def runCommandIgnoringErrors(args):
  """
  Run a shell command ignoring any errors
  """
  return runCommand(args, True)

def verifyCertificate(certPath):
  """
  Verify that a specified module signing certificate is valid and not expired
  """
  logger.info("Verifying the signing certificate validity")
  daySeconds = str(86400)
  valid = False

  # Evaluate if the certificate will expire in the next day
  try:
    result = runCommandIgnoringErrors(['sudo openssl x509 -checkend', daySeconds, '-noout -in',
                                       certPath])
    if ('will not expire' in result.stdout):
      valid = True
    elif ('will expire' in result.stdout):
      logger.info("Certificate will expire within 24 hours - recreating")
  except Exception as error:
      logger.error("Failed to verify certificate validity: {0}".format(error))

  return valid
