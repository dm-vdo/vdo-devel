##
# Perl object that encapsulates a dataset in a directory tree generated by
# genDataBlocks.  The dataset can be accessed either synchronously or
# asynchronously.
#
# The Permabit::GenDataFiles::genDataFiles() method is the approved way to
# create a new dataset and its associated Permabit::GenDataFiles object.  The
# object can then be used to make copies of the dataset using the cp(), gen()
# or tar() methods.  The object can also be used to verify the dataset using
# the verify() method.  The object can also be used to delete the dataset using
# the rm() method.
#
# Any of the methods mentioned above can be used synchronously by just invoking
# the method without the optional async argument or with the async=>0 argument.
# And the methods can be used asynchronously by invoking the method with the
# async=>1 argument.  Used asynchronously, the operation can be in progress in
# a Permabit::AsyncSub.  To ensure that the operation has completed, the
# pollUntilDone() method should be used.
#
# It is possible to mix asynchronous and synchronous operations.  The canRead()
# method will return a true value for any dataset that is safe to read, the
# canDelete() method will return a true value for any dataset that is safe to
# remove and the isDeleted() method will return a true value for any dataset
# that has been removed.
#
# @synopsis
#
#   # Generate and verify a dataset
#   use Permabit::Assertions qw(assertType);
#   use Permabit::Constants;
#   use Permabit::GenDataFiles qw(genDataFiles);
#   assertType("Permabit::FileSystem", $fs);      # precondition
#   my $data = genDataFiles(
#                           async    => $async,
#                           fs       => $fs,
#                           numBytes => 1 * $GB,
#                           numFiles => 100,
#                          );
#   $data->pollUntilDone();                 # Only needed if $async can be true
#   $data->verify(async => $async);
#   $data->pollUntilDone();                 # Only needed if $async can be true
#
#   # Generate and verify a copy of an existing dataset
#   use Permabit::Assertions qw(assertType);
#   assertType("Permabit::GenDataFiles", $data);  # precondition
#   my $copy = $data->generate();
#   $copy->verify();
#
#   # Copy (using cp) and verify an existing dataset
#   use Permabit::Assertions qw(assertTrue assertType);
#   assertType("Permabit::GenDataFiles", $data);  # precondition
#   assertTrue($data->canRead());                 # precondition
#   my $copy = $data->cp();
#   $copy->verify();
#
#   # Copy (using tar) and verify an existing dataset
#   use Permabit::Assertions qw(assertTrue assertType);
#   assertType("Permabit::GenDataFiles", $data);  # precondition
#   assertTrue($data->canRead());                 # precondition
#   my $copy = $data->tar();
#   $copy->verify();
#
#   # Copy/Generate and verify 3 copies of an existing dataset in parallel
#   use Permabit::Assertions qw(assertTrue assertType);
#   assertType("Permabit::GenDataFiles", $data);  # precondition
#   assertTrue($data->canRead());                 # precondition
#   my $cCopy = $data->cp(async => 1);
#   my $gCopy = $data->generate(async => 1);
#   my $tCopy = $data->tar(async => 1);
#   $cCopy->pollUntilDone();
#   $cCopy->verify(async => 1);
#   $gCopy->pollUntilDone();
#   $gCopy->verify(async => 1);
#   $tCopy->pollUntilDone();
#   $tCopy->verify(async => 1);
#   $cCopy->pollUntilDone();
#   $gCopy->pollUntilDone();
#   $tCopy->pollUntilDone();
#
#   # Remove an existing dataset
#   use Permabit::Assertions qw(assertTrue assertType);
#   assertType("Permabit::GenDataFiles", $data);  # precondition
#   assertTrue($data->canDelete());               # precondition
#   $data->rm();
#
#   # Create a 50% duplicate 60% compressible dataset of 2GB using 5000 files
#   use Permabit::Assertions qw(assertType);
#   use Permabit::Constants;
#   use Permabit::GenDataFiles qw(genDataFiles);
#   assertType("Permabit::FileSystem", $fs);      # precondition
#   my $data = genDataFiles(
#                           compress => 0.6,
#                           dedupe   => 0.5,
#                           fs       => $fs,
#                           numBytes => 2 * $GB,
#                           numFiles => 5000,
#                          );
#   my $dataset = genDataFiles($machine, $props);
#
#   # Generate and verify 2 datasets in parallel using Permabit::AsyncSub
#   use Permabit::Assertions qw(assertType);
#   use Permabit::AsyncSub;
#   use Permabit::Constants;
#   use Permabit::GenDataFiles qw(genDataFiles);
#   assertType("Permabit::FileSystem", $fs);      # precondition
#   my $asyncCode = sub {
#     my $data = genDataFiles(
#                             fs       => $fs,
#                             numBytes => 1 * $GB,
#                             numFiles => 100,
#                             tag      => "Async",
#                            );
#     $data->verify();
#   }
#   my $asyncSub = Permabit::AsyncSub->new(code => $asyncCode);
#   $asyncSub->start();
#   my $data = genDataFiles(
#                           fs       => $fs,
#                           numBytes => 1 * $GB,
#                           numFiles => 100,
#                          );
#   $data->verify();
#   $asyncSub->result();
#
# $Id$
##
package Permabit::GenDataFiles;

use strict;
use warnings FATAL => qw(all);
use English qw(-no_match_vars);
use File::Basename;
use Log::Log4perl;
use Permabit::Assertions qw(
  assertDefined
  assertEqualNumeric
  assertLENumeric
  assertMinArgs
  assertMinMaxArgs
  assertNumArgs
  assertType
);
use Permabit::AsyncSub;
use Permabit::Constants;
use Permabit::Exception qw(Verify);
use Permabit::Future::AfterAsyncSub;
use Permabit::Future::List;
use Permabit::Future::Timer;
use Permabit::Utils qw(makeFullPath rethrowException);

use base qw(Exporter);

our @EXPORT_OK = qw(genDataFiles);

my $log = Log::Log4perl->get_logger(__PACKAGE__);

my $setNumber = 0;
my $BLOCK_SIZE = 4 * $KB;

# State constants
my $WRITING  = -1;
my $DELETING = -2;
my $DELETED  = -3;

#############################################################################
# @paramList{new}
my %PROPERTIES
  = (
     # @ple The directory path where the data files live.
     _dir     => undef,
     # @ple True if the files should be written synchronously
     _fsync   => undef,
     # @ple The Permabit::Futures objects for operations on this dataset that
     #      are in progress.
     _futures => undef,
     # @ple The Permabit::UserMachine where the data files live.
     _machine => undef,
     # @ple The options to genDataBlocks that build these data files, and can
     #      be used to verify the dataset.
     _options => undef,
     # @ple State. If non-negative, this is the number of active users of the
     #      dataset.  Otherwise the negative value is $WRITING (writing in
     #      progress), or $DELETING (deleting is in progress) or $DELETED
     #      (deletion complete).
     _state   => $WRITING,
    );
##

#############################################################################
# Create a C<Permabit::GenDataFiles>, and use genDataBlocks to generate the
# data files.  Called using name-value pairs.
#
# @param fs         The filesystem containing the directory the data files will
#                   go into.
# @param numBytes   The total number of bytes to write.
# @param numFiles   The number of files to write.
# @oparam async     True if the generating should be done asynchronously.
# @oparam compress  How much the blocks should compress, from 0 (none) to 0.96
#                   (incredible).
# @oparam dedupe    How much the files should dedupe, from 0 (none) to 1 (total
#                   dedupe).
# @oparam fsync     Call fsync on the data when writing completes.
# @oparam tag       Tag for the data.  This is used inside the generated data
#                   and as the name of the subdirectory containing the files.
#                   The default value uses the state variable $setNumber, which
#                   is fine as long as there is only one test process.  Tests
#                   that call this method from within an AsyncSub should
#                   specify this parameter.
#
# @return a new C<Permabit::GenDataFiles>
##
sub genDataFiles {
  my %args = assertMinArgs(6, @_);
  assertType("Permabit::FileSystem", $args{fs});
  assertDefined($args{numBytes});
  assertDefined($args{numFiles});
  $args{compress} ||= "0";
  $args{dedupe}   ||= "0";

  my $blocksPerFile = int($args{numBytes} / $args{numFiles} / $BLOCK_SIZE);
  $setNumber++;
  my $dir = makeFullPath($args{fs}->getMountDir(),
                         $args{tag} // "gen$setNumber");
  my $data = ("--data=" . ($args{tag} // "D$setNumber"));
  if ($args{dedupe} || $args{compress}) {
    $data .= ",$args{dedupe}";
  }
  if ($args{compress}) {
    $data .= ",$args{compress}";
  }

  my @options = (
                 "--blockCount=$blocksPerFile",
                 $data,
                 "--fileCount=$args{numFiles}",
                );
  my $self = __PACKAGE__->_new(
                               _dir     => $dir,
                               _fsync   => $args{fsync},
                               _machine => $args{fs}->getMachine(),
                               _options => \@options,
                              );
  if ($args{async}) {
    $self->_launch("Generating $self->{_dir}", \&_do_gen, [$self],
                   sub { $self->{_state} = 0; });
  } else {
    $self->_do_gen();
    $self->{_state} = 0;
  }
  return $self;
}

#############################################################################
# Create a C<Permabit::GenDataFiles>.
#
# @params{new}
##
sub _new {
  my $invocant = shift;
  my $class = ref($invocant) || $invocant;
  return bless { %PROPERTIES,
                 # Overrides previous values
                 @_,
                 # Must construct a new object here
                 _futures => Permabit::Future::List->new(),
               }, $class;
}

#############################################################################
# Apply a function to each asynchronous operation that is done.
#
# @param code  Code to apply to each C<Permabit::Future> that is in progress
##
sub apply {
  my ($self, $code) = assertNumArgs(2, @_);
  $self->{_futures}->apply($code);
}

#############################################################################
# Determine if the dataset is present on the storage medium so that it can be
# safely deleted.
#
# @return true if the dataset can be deleted.
##
sub canDelete {
  my ($self) = assertNumArgs(1, @_);
  return $self->{_state} == 0;
}

#############################################################################
# Determine if the dataset is present on the storage medium so that it can be
# safely read.
#
# @return true if the dataset can be read
##
sub canRead {
  my ($self) = assertNumArgs(1, @_);
  return $self->{_state} >= 0;
}

#############################################################################
# Count the number of active operations on the dataset.  An operation means a
# command that is reading the dataset (such as cp, tar, or genDataBlocks
# verify) or a command that is writing the dataset (such as cp, tar or
# genDataBlocks write).
#
# @return the number of operations
##
sub countOperations {
  my ($self) = assertNumArgs(1, @_);
  if ($self->{_state} >= 0) {
    return $self->{_state};
  }
  return $self->{_state} == $DELETED ? 0 : 1;
}

#############################################################################
# Generate a new C<Permabit::GenDataFiles> that is a copy of an existing
# C<Permabit::GenDataFiles> using cp.  Called using name-value pairs.
#
# @oparam async  True if the write should be done asynchronously.
##
sub cp {
  my ($self, %args) = assertMinArgs(1, @_);
  assertLENumeric(0, $self->{_state});
  return $self->_clone(%args, writer => "cp", readCount => 1);
}

#############################################################################
# Generate a new C<Permabit::GenDataFiles> that is a copy of an existing
# C<Permabit::GenDataFiles> using genDataBlocks.  Called using name-value
# pairs.
#
# @oparam async  True if the write should be done asynchronously.
##
sub generate {
  my ($self, %args) = assertMinArgs(1, @_);
  return $self->_clone(%args, writer => "gen", readCount => 0);
}

#############################################################################
# Determine if the dataset has been deleted.
#
# @return true if the dataset is deleted.
##
sub isDeleted {
  my ($self) = assertNumArgs(1, @_);
  return ($self->{_state} == $DELETED);
}

#############################################################################
# Determine if the dataset is being written to the storage medium.
#
# @return true if the dataset is being written
##
sub isWriting {
  my ($self) = assertNumArgs(1, @_);
  return $self->{_state} == $WRITING;
}

#############################################################################
# Kill any asynchronous operations that are still running.
##
sub kill {
  my ($self) = assertNumArgs(1, @_);
  my $stopSub = sub {
    my ($future) = assertNumArgs(1, @_);
    # Make sure the future doesn't die if the AsyncSub returns an error.
    $future->{onError} = sub { };
    $future->{asyncSub}->kill('SIGTERM');
  };
  $self->{_futures}->apply($stopSub);
  $self->{_futures}->pollUntilDone();
}

#############################################################################
# Poll for any asynchronous operation that is done.
##
sub poll {
  my ($self) = assertNumArgs(1, @_);
  $self->{_futures}->poll();
}

#############################################################################
# Wait for all asynchronous operations to finish.
##
sub pollUntilDone {
  my ($self) = assertNumArgs(1, @_);
  $self->{_futures}->pollUntilDone();
}

#############################################################################
# Remove the dataset.  Called using name-value pairs.
##
sub rm {
  my ($self, %args) = assertMinArgs(1, @_);
  assertLENumeric(0, $self->{_state});
  $self->{_state} = $DELETING;
  if ($args{async}) {
    $self->_launch("Removing $self->{_dir}", \&_do_rm, [$self],
                   sub { $self->{_state} = $DELETED; });
  } else {
    $self->_do_rm();
    $self->{_state} = $DELETED;
  }
}

#############################################################################
# Generate a new C<Permabit::GenDataFiles> that is a copy of an existing
# C<Permabit::GenDataFiles> using tar.  Called using name-value pairs.
#
# @oparam async  True if the write should be done asynchronously.
##
sub tar {
  my ($self, %args) = assertMinArgs(1, @_);
  assertLENumeric(0, $self->{_state});
  return $self->_clone(%args, writer => "tar", readCount => 1);
}

#############################################################################
# Verify the dataset.  Called using name-value pairs.
#
# @oparam async  True if the verify should be done asynchronously.
##
sub verify {
  my ($self, %args) = assertMinArgs(1, @_);
  assertLENumeric(0, $self->{_state});
  if ($args{async}) {
    $self->{_state}++;
    $self->_launch("Verifying $self->{_dir}", \&_do_verify, [$self],
                   sub { $self->{_state}--; });
  } else {
    $self->_do_verify();
  }
}

#############################################################################
# Copy a dataset
#
# @param readCount  Number of readers to add to the source dataset
# @param writer     Copy method
# @oparam async     True if the copy should be done asynchronously.
#
# @return a C<Permabit::GenDataFiles>
##
sub _clone {
  my ($self, %args) = assertMinArgs(5, @_);
  assertDefined($args{readCount});
  assertDefined($args{writer});
  my $writer = $args{writer};
  my $dir = makeFullPath(dirname($self->{_dir}), $writer . (++$setNumber));
  my $clone = $self->_new(
                          _dir     => $dir,
                          _fsync   => $self->{_fsync},
                          _machine => $self->{_machine},
                          _options => $self->{_options},
                         );
  $self->{_state} += $args{readCount};
  my $doMethod = "_do_$writer";
  my $finishMethod = sub {
    assertNumArgs(0, @_);
    $self->{_state} -= $args{readCount};
    $clone->{_state} = 0;
  };
  if ($args{async}) {
    $clone->_launch("Cloning $self->{_dir} to $clone->{_dir} using $writer",
                   \&$doMethod, [$clone, $self], $finishMethod, $self);
  } else {
    $clone->$doMethod($self);
    $finishMethod->();
  }

  return $clone;
}

#############################################################################
# Write the data set using cp to copy an existing dataset.  This code may run
# asynchronously.
#
# @param source  Source dataset
##
sub _do_cp {
  my ($self, $source) = assertNumArgs(2, @_);
  $self->{_machine}->runSystemCmd("cp -r $source->{_dir} $self->{_dir}");
  if ($self->{_fsync}) {
    $self->{_machine}->fsync($self->{_dir});
  }
}

#############################################################################
# Write the data set using genDataBlocks.  This code may run asynchronously.
#
# @oparam source  Source dataset (not used)
##
sub _do_gen {
  my ($self, $source) = assertMinMaxArgs(1, 2, @_);
  $self->_genDataBlocks("writeFiles");
  if ($self->{_fsync}) {
    $self->{_machine}->fsync($self->{_dir});
  }
}

#############################################################################
# The actual code to remove the dataset.  This code may run asynchronously.
##
sub _do_rm {
  my ($self) = assertNumArgs(1, @_);
  my $dir = $self->{_dir};
  $self->{_machine}->runSystemCmd("rm -fr $self->{_dir}");
  if ($self->{_fsync}) {
    $self->{_machine}->fsync("--rm", $self->{_dir});
  }
}

#############################################################################
# Write the data set using tar to copy an existing dataset.  This code may run
# asynchronously.
#
# @param source  Source dataset
##
sub _do_tar {
  my ($self, $source) = assertNumArgs(2, @_);
  $self->{_machine}->runSystemCmd("mkdir -p $self->{_dir}");
  my $tarCopy = "tar cf - -C $source->{_dir} . | tar xf - -C $self->{_dir}";
  $self->{_machine}->runSystemCmd($tarCopy);
  if ($self->{_fsync}) {
    $self->{_machine}->fsync($self->{_dir});
  }
}

#############################################################################
# The actual code to verify the dataset.  This code may run asynchronously.
##
sub _do_verify {
  my ($self) = assertNumArgs(1, @_);
  eval { $self->_genDataBlocks("verifyFiles"); };
  if (my $firstError = $EVAL_ERROR) {
    rethrowException($firstError, "Permabit::Exception::SSH");
    rethrowException($firstError, "Permabit::Exception::Signal");
    $log->fatal("First verify error: $firstError");
    eval { $self->_genDataBlocks("verifyFiles"); };
    my $secondResult = "second verify succeeded";
    if (my $secondError = $EVAL_ERROR) {
      $log->fatal("Second verify error: $secondError");
      $secondResult = "second verify failed";
    }
    my $error = "First verify failed, $secondResult - $firstError";
    die(Permabit::Exception::Verify->new($error));
  }
}

#############################################################################
# Run genDataBlocks.
#
# @param action     The genDataBlocks action ("verify" or "write")
##
sub _genDataBlocks {
  my ($self, $action) = assertNumArgs(2, @_);
  my $machine  = $self->{_machine};
  my $cmd = join(" ", "genDataBlocks", "--dir=$self->{_dir}",
                 @{$self->{_options}}, $action);
  $machine->runSystemCmd($cmd);
}

#############################################################################
# Launch an asynchronous operation, and add a future for its completion.
#
# @param whatFor    Name of the operation
# @param startSub   Code to start the operation in the AsyncSub process
# @param startArgs  Arguments for startSub
# @param doneSub    Code to complete the operation in this process
# @param clone      Clone that the future must also be added to
##
sub _launch {
  my ($self, $whatFor, $startSub, $startArgs, $doneSub, $clone)
    = assertMinMaxArgs([undef], 5, 6, @_);
  my $task = Permabit::AsyncSub->new(code => $startSub, args => $startArgs);
  $task->start();
  my $future = Permabit::Future::AfterAsyncSub->new(asyncSub  => $task,
                                                    onSuccess => $doneSub,
                                                    whatFor   => $whatFor);
  $self->{_futures}->add($future);
  if (defined($clone)) {
    $clone->{_futures}->add($future);
  }
}

1;
